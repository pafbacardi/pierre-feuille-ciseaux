<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bataille Navale - Multijoueur</title>
    <!-- Favicon emoji üí• -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí•</text></svg>">
    <!-- Tailwind CSS CDN pour un stylisme rapide et responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Configuration de Tailwind pour les couleurs personnalis√©es et les animations */
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

        :root {
            --color-deep-blue: #001F3F; /* Bleu marine tr√®s fonc√© */
            --color-ocean-blue: #0074D9; /* Bleu oc√©an vif */
            --color-sky-blue: #7FDBFF; /* Bleu ciel clair */
            --color-steel-gray: #6C7A89; /* Gris acier */
            --color-slate-gray: #34495E; /* Gris ardoise */
            --color-fire-red: #FF4136; /* Rouge feu */
            --color-burnt-orange: #FF851B; /* Orange br√ªl√© */

            /* Nouvelles couleurs pour les grilles */
            --color-player-grid-water: #6CB6D9; /* Bleu plus clair pour la grille du joueur */
            --color-opponent-grid-water: #0074D9; /* Bleu oc√©an pour la grille de l'adversaire */
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, var(--color-sky-blue) 0%, var(--color-ocean-blue) 50%, var(--color-deep-blue) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            color: white;
            overflow-x: hidden; /* Emp√™che le d√©filement horizontal */
        }

        /* Conteneur principal du jeu */
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1000px;
            padding: 0 1rem;
        }

        /* Conteneur des grilles pour le responsive */
        .game-area {
            display: flex;
            flex-direction: column; /* Par d√©faut en colonne (portrait sur petits √©crans) */
            gap: 2rem;
            align-items: center;
            width: 100%;
            max-width: 1000px; /* Limite la largeur maximale pour l'ensemble des grilles */
            padding: 0 1rem; /* Ajoute un peu de padding horizontal */
        }

        /* Pour les √©crans plus larges (tablettes/ordinateurs) - les grilles sont c√¥te √† c√¥te */
        @media (min-width: 768px) {
            .game-area {
                flex-direction: row;
                justify-content: center;
            }
        }

        /* Ajustement sp√©cifique pour les smartphones en mode paysage */
        @media (max-width: 767px) and (orientation: landscape) {
            .game-area {
                flex-direction: row;
                justify-content: center;
                gap: 0.5rem; /* R√©duire le gap pour les petits √©crans en paysage */
                padding: 0 0.5rem; /* R√©duire le padding pour maximiser l'espace */
            }
        }

        /* Styles de la grille */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(11, 1fr); /* 10 colonnes + 1 pour les num√©ros */
            grid-template-rows: repeat(11, 1fr); /* 10 lignes + 1 pour les lettres */
            gap: 1px; /* Espacement entre les cases */
            background-color: var(--color-slate-gray); /* Bordure de la grille */
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            width: 90vw; /* Utilise 90% de la largeur de la vue par d√©faut */
            max-width: 400px; /* Limite la taille max pour les tr√®s grands √©crans */
            aspect-ratio: 1 / 1; /* Maintient la grille carr√©e */
        }

        /* Ajustement de la taille des grilles pour les smartphones en mode paysage */
        @media (max-width: 767px) and (orientation: landscape) {
            .grid-container {
                width: 47vw; /* Environ la moiti√© de la largeur de l'√©cran, moins le gap */
                height: 47vw; /* Maintenir l'aspect ratio */
                max-width: none; /* Supprimer la limite max-width pour permettre le 47vw */
            }
        }

        .grid-cell {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            user-select: none; /* Emp√™che la s√©lection de texte */
        }

        /* Couleurs sp√©cifiques pour les cellules d'eau des grilles */
        #my-grid .grid-cell:not(.header) {
            background-color: var(--color-player-grid-water);
        }

        #opponent-grid .grid-cell:not(.header) {
            background-color: var(--color-opponent-grid-water);
        }

        .grid-cell.header {
            background-color: var(--color-steel-gray);
            cursor: default;
        }

        .grid-cell:not(.header):hover {
            background-color: var(--color-sky-blue); /* Effet hover sur les cases de jeu */
        }

        /* Styles des bateaux */
        .ship {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.25rem;
            position: absolute;
            width: calc(100% - 2px); /* Ajustement pour la bordure */
            height: calc(100% - 2px);
            z-index: 10; /* Assure que le bateau est au-dessus de la case */
        }

        /* Styles pour le placement */
        .ship-to-place {
            background-color: var(--color-steel-gray);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            /* La couleur sera d√©finie directement en JS pour correspondre au bateau */
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .ship-to-place.selected {
            background-color: var(--color-ocean-blue) !important; /* !important pour override le style inline */
            box-shadow: 0 0 0 3px var(--color-sky-blue);
        }

        .ship-preview {
            background-color: rgba(108, 122, 137, 0.7); /* Gris semi-transparent pour l'aper√ßu */
            position: absolute;
            z-index: 5; /* En dessous du marqueur mais au-dessus de l'eau */
            border-radius: 0.25rem;
        }

        .invalid-placement {
            background-color: rgba(255, 65, 54, 0.5); /* Rouge semi-transparent pour placement invalide */
        }

        /* Animations */
        @keyframes hit-animation {
            0% {
                transform: scale(0.5);
                opacity: 0;
                background-color: var(--color-fire-red);
            }
            20% {
                transform: scale(1.2);
                opacity: 1;
                background-color: var(--color-burnt-orange);
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
                background-color: var(--color-fire-red);
            }
        }

        .hit-effect::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            animation: hit-animation 0.7s ease-out forwards;
            z-index: 20; /* Au-dessus de tout */
        }

        @keyframes miss-animation {
            0% {
                transform: scale(0.5);
                opacity: 0;
                background-color: var(--color-sky-blue);
                box-shadow: 0 0 0 0 rgba(127, 219, 255, 0.7);
            }
            50% {
                transform: scale(1);
                opacity: 1;
                background-color: var(--color-sky-blue);
                box-shadow: 0 0 0 10px rgba(127, 219, 255, 0.3);
            }
            100% {
                transform: scale(1.2);
                opacity: 0;
                background-color: var(--color-sky-blue);
                box-shadow: 0 0 0 20px rgba(127, 219, 255, 0);
            }
        }

        .miss-effect::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            animation: miss-animation 0.9s ease-out forwards;
            z-index: 20;
        }

        /* Styles pour les emojis marqueurs */
        .emoji-marker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem; /* Taille de l'emoji r√©duite */
            z-index: 15; /* Au-dessus de la case */
            pointer-events: none; /* Permet de cliquer √† travers l'emoji si besoin */
        }

        /* Boutons de simulation (maintenant pour le debug ou pour un mode IA si impl√©ment√©) */
        .simulation-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .simulation-buttons button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .simulation-buttons button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        .simulation-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .simulation-buttons .btn-hit {
            background-color: var(--color-fire-red);
            color: white;
            border: none;
        }

        .simulation-buttons .btn-miss {
            background-color: var(--color-ocean-blue);
            color: white;
            border: none;
        }

        /* Message d'√©tat */
        #game-message {
            margin-top: 1.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            min-height: 2rem; /* Pour √©viter le Cumulative Layout Shift (CLS) */
            text-align: center;
        }

        #version-info {
            margin-top: 2rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Styles sp√©cifiques √† la phase de placement */
        #placement-controls {
            display: flex; /* Par d√©faut, il est flex, pas 'hidden' */
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 2rem;
            width: 100%;
            max-width: 400px;
        }

        #ships-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
        }

        #placement-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Styles pour le bouton Rejouer */
        #replay-button {
            background-color: #4CAF50; /* Vert */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
            cursor: pointer;
        }

        #replay-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        /* Styles pour le lobby multijoueur */
        #multiplayer-lobby {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            margin-bottom: 2rem;
            text-align: center;
        }

        #multiplayer-lobby input {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 0.5rem;
            padding: 0.75rem;
            color: white;
            margin-bottom: 1rem;
            width: 100%;
            max-width: 300px;
            text-align: center;
        }

        #multiplayer-lobby button {
            background-color: #007BFF; /* Bleu */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin: 0.5rem;
            cursor: pointer;
        }

        #multiplayer-lobby button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        #multiplayer-info {
            margin-top: 1rem;
            font-size: 1rem;
        }

        /* Styles pour l'indicateur de tour principal (bleu) */
        .turn-indicator {
            box-shadow: 0 0 15px 5px var(--color-sky-blue); /* Lumi√®re bleue */
            border-radius: 0.75rem; /* Arrondir l√©g√®rement les coins du glow */
            padding: 0.5rem 1rem;
            transition: box-shadow 0.3s ease-in-out;
        }

        /* Nouveau style pour l'indicateur de cible (rouge brillant) */
        .target-indicator {
            box-shadow: 0 0 15px 5px var(--color-fire-red); /* Rouge vif */
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            transition: box-shadow 0.3s ease-in-out;
        }
    </style>
</head>
<body>
    <h1 class="text-4xl md:text-5xl font-bold mb-8 text-shadow-lg">Bataille Navale</h1>

    <div id="game-message" class="text-center"></div>

    <!-- Lobby Multijoueur -->
    <div id="multiplayer-lobby" class="flex flex-col items-center">
        <h2 class="text-2xl font-semibold mb-4">Rejoindre ou Cr√©er une Partie</h2>
        <p class="mb-2">Ton ID Joueur : <span id="user-id-display">Chargement...</span></p>
        <input type="text" id="game-id-input" placeholder="ID de la partie √† rejoindre">
        <div class="flex flex-wrap justify-center gap-2">
            <button id="create-game-btn">Cr√©er une nouvelle partie</button>
            <button id="join-game-btn">Rejoindre la partie</button>
        </div>
        <p id="multiplayer-info" class="mt-4"></p>
    </div>

    <div id="game-container" class="hidden"> <!-- Cacher le conteneur du jeu au d√©marrage -->
        <!-- Ma Grille (pour visualiser mes bateaux et placer) -->
        <div class="flex flex-col items-center">
            <h2 id="my-grid-title" class="text-2xl font-semibold mb-4">Ma Grille</h2>
            <div id="my-grid" class="grid-container">
                <!-- Les cellules de la grille seront g√©n√©r√©es ici par JS -->
            </div>
        </div>

        <!-- Grille de l'Adversaire (pour tirer) - cach√©e pendant le placement -->
        <div class="flex flex-col items-center hidden" id="opponent-grid-section">
            <h2 id="opponent-grid-title" class="text-2xl font-semibold mb-4">Grille de l'Adversaire</h2>
            <div id="opponent-grid" class="grid-container">
                <!-- Les cellules de la grille seront g√©n√©r√©es ici par JS -->
            </div>
        </div>
    </div>

    <!-- Contr√¥les de placement des bateaux -->
    <div id="placement-controls" class="hidden"> <!-- Cacher par d√©faut, affich√© via JS -->
        <h3 class="text-xl font-semibold mb-2">Bateaux √† placer :</h3>
        <div id="ships-list" class="flex flex-wrap justify-center gap-3 mb-4">
            <!-- Les bateaux seront g√©n√©r√©s ici par JS -->
        </div>
        <div id="placement-buttons">
            <button id="rotate-ship-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg">
                Rotation
            </button>
            <button id="validate-placement-btn" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg" disabled>
                Valider mon placement
            </button>
        </div>
    </div>

    <!-- Boutons de simulation (maintenant pour le debug ou pour un mode IA si impl√©ment√©) -->
    <div class="simulation-buttons hidden">
        <button id="simulate-hit" class="btn-hit">Simuler "Touch√©" Al√©atoire</button>
        <button id="simulate-miss" class="btn-miss">Simuler "Dans l'Eau" Al√©atoire</button>
    </div>

    <!-- Bouton Rejouer (cach√© par d√©faut) -->
    <button id="replay-button" class="hidden">Rejouer</button>

    <div id="version-info">Version: 1.0.27</div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // R√©cup√©ration des √©l√©ments du DOM
        const myGridElement = document.getElementById('my-grid');
        const opponentGridElement = document.getElementById('opponent-grid');
        const opponentGridSection = document.getElementById('opponent-grid-section');
        const gameMessageElement = document.getElementById('game-message');
        const simulateHitButton = document.getElementById('simulate-hit');
        const simulateMissButton = document.getElementById('simulate-miss');
        const placementControls = document.getElementById('placement-controls');
        const shipsListElement = document.getElementById('ships-list');
        const rotateShipButton = document.getElementById('rotate-ship-btn');
        const validatePlacementButton = document.getElementById('validate-placement-btn');
        const simulationButtonsContainer = document.querySelector('.simulation-buttons');
        const replayButton = document.getElementById('replay-button');

        // Nouveaux √©l√©ments pour l'indicateur de tour
        const myGridTitle = document.getElementById('my-grid-title');
        const opponentGridTitle = document.getElementById('opponent-grid-title');

        // √âl√©ments du lobby multijoueur
        const multiplayerLobby = document.getElementById('multiplayer-lobby');
        const gameIdInput = document.getElementById('game-id-input');
        const createGameBtn = document.getElementById('create-game-btn');
        const joinGameBtn = document.getElementById('join-game-btn');
        const userIdDisplay = document.getElementById('user-id-display');
        const multiplayerInfo = document.getElementById('multiplayer-info');
        const gameContainer = document.getElementById('game-container'); // Le conteneur principal du jeu

        const gridSize = 10; // Taille de la grille (10x10)
        const alphabet = 'ABCDEFGHIJ'; // Lettres pour les coordonn√©es

        // D√©finition des bateaux (longueur, nom et couleur)
        const initialShips = [
            { id: 'carrier', name: 'Porte-avions', length: 5, placed: false, position: [], color: '#FF4136', hits: 0, sunk: false },
            { id: 'battleship', name: 'Cuirass√©', length: 4, placed: false, position: [], color: '#0074D9', hits: 0, sunk: false },
            { id: 'cruiser', name: 'Croiseur', length: 3, placed: false, position: [], color: '#2ECC40', hits: 0, sunk: false },
            { id: 'submarine', name: 'Sous-marin', length: 3, placed: false, position: [], color: '#FFDC00', hits: 0, sunk: false },
            { id: 'destroyer', name: 'Torpilleur', length: 2, placed: false, position: [], color: '#B10DC9', hits: 0, sunk: false }
        ];

        // Variables Firebase
        let app;
        let db;
        let auth;
        let currentUserId = null;
        let currentGameId = null;
        let currentPlayerNumber = null; // 1 for player1, 2 for player2
        let unsubscribeGameListener = null; // Pour d√©sabonner le listener Firestore

        // √âtat du jeu local, synchronis√© avec Firestore
        let gameData = null;
        let selectedShip = null;
        let currentShipOrientation = 'horizontal';

        // Initialisation de Firebase avec la configuration fournie directement
        const firebaseConfig = {
            apiKey: "AIzaSyB4ci8440mSqxxEx7eNDuUUhGY5WWuyPyA",
            authDomain: "bataille-navale-f9380.firebaseapp.com",
            projectId: "bataille-navale-f9380",
            storageBucket: "bataille-navale-f9380.firebasestorage.app",
            messagingSenderId: "502015941698",
            appId: "1:502015941698:web:dca1f46ddebec5378d21db"
        };
        const appId = "1:502015941698:web:dca1f46ddebec5378d21db"; // Utilisation directe de l'appId fourni

        // Initialisation de l'application Firebase
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        // Authentification anonyme
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = currentUserId;
                multiplayerInfo.textContent = "Authentifi√©. Cr√©e ou rejoins une partie.";
            } else {
                try {
                    // Utilise __initial_auth_token si disponible, sinon authentification anonyme
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Erreur d'authentification:", error);
                    multiplayerInfo.textContent = "Erreur d'authentification. Veuillez r√©essayer.";
                }
            }
        });

        /**
         * Cr√©e une nouvelle partie dans Firestore.
         */
        createGameBtn.addEventListener('click', async () => {
            if (!currentUserId) {
                multiplayerInfo.textContent = "Authentification en cours... Veuillez patienter.";
                return;
            }

            // G√©n√©rer un ID de partie simple pour le prototype
            const newGameId = Math.random().toString(36).substring(2, 8).toUpperCase();
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/battleship_games`, newGameId);

            try {
                // V√©rifier si la partie existe d√©j√† (peu probable avec un ID al√©atoire, mais bonne pratique)
                const docSnap = await getDoc(gameDocRef);
                if (docSnap.exists()) {
                    multiplayerInfo.textContent = `La partie ${newGameId} existe d√©j√†. Essaye un autre ID ou rejoins-la.`;
                    return;
                }

                // Initialiser l'√©tat de la partie
                const initialGameState = {
                    player1Id: currentUserId,
                    player2Id: null, // En attente du deuxi√®me joueur
                    // S√©rialiser les grilles et les bateaux en JSON strings
                    player1Grid: JSON.stringify(Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))),
                    player2Grid: JSON.stringify(Array(gridSize).fill(null).map(() => Array(gridSize).fill(0))),
                    player1Ships: JSON.stringify(initialShips),
                    player2Ships: JSON.stringify(initialShips),
                    currentPlayerTurn: currentUserId, // Le cr√©ateur commence le placement
                    status: 'waiting', // 'waiting', 'placement', 'playing', 'finished'
                    winner: null,
                    createdAt: new Date(),
                    lastUpdated: new Date(),
                    player1PlacementDone: false, // Nouveau champ pour le suivi du placement
                    player2PlacementDone: false  // Nouveau champ pour le suivi du placement
                };

                await setDoc(gameDocRef, initialGameState);
                currentGameId = newGameId;
                currentPlayerNumber = 1;
                multiplayerInfo.textContent = `Partie cr√©√©e ! ID: ${newGameId}. En attente du joueur 2.`;
                gameIdInput.value = newGameId; // Pr√©-remplir l'input pour faciliter le partage
                listenForGameUpdates(newGameId); // √âcouter les changements
                multiplayerLobby.classList.add('hidden'); // Cacher le lobby
                gameContainer.classList.remove('hidden'); // Afficher le conteneur du jeu
                // updateGameDisplay() sera appel√© par le listener
            } catch (e) {
                console.error("Erreur lors de la cr√©ation de la partie: ", e);
                multiplayerInfo.textContent = "Erreur lors de la cr√©ation de la partie.";
            }
        });

        /**
         * Rejoindre une partie existante.
         */
        joinGameBtn.addEventListener('click', async () => {
            if (!currentUserId) {
                multiplayerInfo.textContent = "Authentification en cours... Veuillez patienter.";
                return;
            }

            const gameIdToJoin = gameIdInput.value.trim().toUpperCase();
            if (!gameIdToJoin) {
                multiplayerInfo.textContent = "Veuillez entrer un ID de partie.";
                return;
            }

            const gameDocRef = doc(db, `artifacts/${appId}/public/data/battleship_games`, gameIdToJoin);

            try {
                const docSnap = await getDoc(gameDocRef);

                if (!docSnap.exists()) {
                    multiplayerInfo.textContent = `La partie ${gameIdToJoin} n'existe pas.`;
                    return;
                }

                const data = docSnap.data();

                if (data.player1Id === currentUserId || data.player2Id === currentUserId) {
                    // Reconnexion √† une partie d√©j√† rejointe
                    currentGameId = gameIdToJoin;
                    currentPlayerNumber = (data.player1Id === currentUserId) ? 1 : 2;
                    multiplayerInfo.textContent = `Rejoint la partie ${gameIdToJoin}.`;
                    listenForGameUpdates(gameIdToJoin);
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    // updateGameDisplay() sera appel√© par le listener
                    return;
                }

                if (data.player2Id && data.player2Id !== currentUserId) {
                    multiplayerInfo.textContent = `La partie ${gameIdToJoin} est d√©j√† pleine.`;
                    return;
                }

                // Rejoindre en tant que joueur 2
                await updateDoc(gameDocRef, {
                    player2Id: currentUserId,
                    status: 'placement', // La partie passe en phase de placement une fois 2 joueurs
                    lastUpdated: new Date()
                });

                currentGameId = gameIdToJoin;
                currentPlayerNumber = 2;
                multiplayerInfo.textContent = `Rejoint la partie ${gameIdToJoin} en tant que joueur 2.`;
                listenForGameUpdates(gameIdToJoin);
                multiplayerLobby.classList.add('hidden');
                gameContainer.classList.remove('hidden');
                // updateGameDisplay() sera appel√© par le listener
            } catch (e) {
                console.error("Erreur lors de la jonction de la partie: ", e);
                multiplayerInfo.textContent = "Erreur lors de la jonction de la partie.";
            }
        });

        /**
         * √âcoute les mises √† jour de l'√©tat du jeu depuis Firestore.
         * @param {string} gameId - L'ID de la partie √† √©couter.
         */
        function listenForGameUpdates(gameId) {
            if (unsubscribeGameListener) {
                unsubscribeGameListener(); // D√©sabonne l'ancien listener si existant
            }

            const gameDocRef = doc(db, `artifacts/${appId}/public/data/battleship_games`, gameId);
            unsubscribeGameListener = onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    gameData = docSnap.data();
                    // D√©s√©rialiser les grilles et les bateaux
                    gameData.player1Grid = JSON.parse(gameData.player1Grid);
                    gameData.player2Grid = JSON.parse(gameData.player2Grid);
                    gameData.player1Ships = JSON.parse(gameData.player1Ships);
                    gameData.player2Ships = JSON.parse(gameData.player2Ships);

                    updateGameDisplay(); // Met √† jour l'interface utilisateur
                } else {
                    console.log("La partie n'existe plus.");
                    gameMessageElement.textContent = "La partie a √©t√© supprim√©e ou n'existe plus.";
                    resetGame(); // Revenir √† l'√©tat initial
                }
            }, (error) => {
                console.error("Erreur d'√©coute Firestore:", error);
                gameMessageElement.textContent = "Erreur de connexion √† la partie.";
            });
        }

        /**
         * Met √† jour l'√©tat du jeu dans Firestore.
         * @param {object} updates - Les champs √† mettre √† jour.
         */
        async function updateGameInFirestore(updates) {
            if (!currentGameId) {
                console.error("Aucune partie s√©lectionn√©e pour la mise √† jour.");
                return;
            }
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/battleship_games`, currentGameId);
            
            // S√©rialiser les donn√©es avant d'envoyer √† Firestore
            const updatesToSend = { ...updates };
            for (const key in updatesToSend) {
                if (key === 'player1Grid' || key === 'player2Grid' || key === 'player1Ships' || key === 'player2Ships') {
                    updatesToSend[key] = JSON.stringify(updatesToSend[key]);
                }
            }

            try {
                await updateDoc(gameDocRef, { ...updatesToSend, lastUpdated: new Date() });
            } catch (e) {
                console.error("Erreur lors de la mise √† jour Firestore:", e);
                gameMessageElement.textContent = "Erreur de synchronisation avec le serveur.";
            }
        }

        /**
         * Initialise ou r√©initialise le jeu.
         */
        function resetGame() {
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }
            gameData = null;
            currentGameId = null;
            currentPlayerNumber = null;
            selectedShip = null;
            currentShipOrientation = 'horizontal';
            gameMessageElement.textContent = "";
            replayButton.classList.add('hidden');
            multiplayerLobby.classList.remove('hidden'); // Affiche le lobby
            gameContainer.classList.add('hidden'); // Cache le jeu principal
            userIdDisplay.textContent = currentUserId; // R√©affiche l'ID utilisateur
            multiplayerInfo.textContent = "Authentifi√©. Cr√©e ou rejoins une partie.";
            gameIdInput.value = ''; // Vide l'input de l'ID de partie
            // R√©initialise l'affichage des grilles
            myGridElement.innerHTML = '';
            opponentGridElement.innerHTML = '';
            // R√©initialise les indicateurs de tour
            myGridTitle.classList.remove('turn-indicator', 'target-indicator');
            opponentGridTitle.classList.remove('turn-indicator', 'target-indicator');
        }

        /**
         * Met √† jour l'affichage du jeu en fonction de la phase actuelle et des donn√©es Firestore.
         */
        function updateGameDisplay() {
            if (!gameData) {
                gameMessageElement.textContent = "En attente des donn√©es de la partie...";
                return;
            }

            // D√©termine quelle grille est la n√¥tre et laquelle est celle de l'adversaire
            let myPlayerGridState;
            let myPlayerShips;
            let opponentPlayerGridState;
            let opponentPlayerShips;
            let opponentId;

            if (gameData.player1Id === currentUserId) {
                myPlayerGridState = gameData.player1Grid;
                myPlayerShips = gameData.player1Ships;
                opponentPlayerGridState = gameData.player2Grid;
                opponentPlayerShips = gameData.player2Ships;
                opponentId = gameData.player2Id;
            } else if (gameData.player2Id === currentUserId) {
                myPlayerGridState = gameData.player2Grid;
                myPlayerShips = gameData.player2Ships;
                opponentPlayerGridState = gameData.player1Grid;
                opponentPlayerShips = gameData.player1Ships;
                opponentId = gameData.player1Id;
            } else {
                // Spectateur ou partie non pertinente
                gameMessageElement.textContent = "Tu n'es pas dans cette partie. Rejoins-en une ou cr√©e-en une nouvelle.";
                multiplayerLobby.classList.remove('hidden');
                gameContainer.classList.add('hidden');
                return;
            }

            // Met √† jour l'affichage de l'ID de partie
            multiplayerInfo.textContent = `Partie ID: ${currentGameId} | Joueur ${currentPlayerNumber}`;

            // R√©initialise tous les indicateurs de tour avant d'appliquer les nouveaux
            myGridTitle.classList.remove('turn-indicator', 'target-indicator');
            opponentGridTitle.classList.remove('turn-indicator', 'target-indicator');

            // Logique d'affichage bas√©e sur le statut de la partie
            switch (gameData.status) {
                case 'waiting':
                    gameMessageElement.textContent = `En attente du joueur 2... ID de la partie: ${currentGameId}`;
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    placementControls.classList.add('hidden');
                    placementControls.style.display = 'none';
                    opponentGridSection.classList.add('hidden');
                    simulationButtonsContainer.classList.add('hidden');
                    replayButton.classList.add('hidden');
                    break;

                case 'placement':
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    placementControls.classList.remove('hidden');
                    placementControls.style.display = 'flex';
                    opponentGridSection.classList.add('hidden');
                    simulationButtonsContainer.classList.add('hidden');
                    replayButton.classList.add('hidden');

                    gameMessageElement.textContent = "Place tes bateaux sur ta grille !";
                    createGrid(myGridElement, false, true); // Ma grille est cliquable pour le placement
                    renderShipsList(myPlayerShips); // Utilise les bateaux du joueur actuel
                    renderPlacedShipsOnMyGrid(myPlayerGridState, myPlayerShips); // Affiche les bateaux du joueur actuel
                    break;

                case 'playing':
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    placementControls.classList.add('hidden');
                    placementControls.style.display = 'none';
                    opponentGridSection.classList.remove('hidden');
                    simulationButtonsContainer.classList.add('hidden'); // Masque les boutons de simulation en multijoueur
                    replayButton.classList.add('hidden');

                    createGrid(myGridElement, false, false); // Ma grille n'est plus cliquable pour le placement
                    createGrid(opponentGridElement, true, false); // Grille adversaire cliquable pour le tir

                    renderPlacedShipsOnMyGrid(myPlayerGridState, myPlayerShips); // Affiche les bateaux du joueur actuel
                    renderOpponentGridShots(opponentPlayerGridState); // Affiche les tirs sur la grille de l'adversaire

                    if (gameData.currentPlayerTurn === currentUserId) {
                        gameMessageElement.textContent = "C'est ton tour ! Clique sur la grille de l'adversaire pour tirer.";
                        myGridTitle.classList.add('turn-indicator'); // Indicateur bleu sur ma grille
                        opponentGridTitle.classList.add('target-indicator'); // Indicateur rouge sur la grille adverse
                        opponentGridElement.style.pointerEvents = 'auto'; // Active les clics sur la grille adverse
                    } else {
                        gameMessageElement.textContent = "C'est le tour de l'adversaire...";
                        opponentGridTitle.classList.add('turn-indicator'); // Indicateur bleu sur la grille adverse (pour montrer que c'est leur tour)
                        myGridTitle.classList.remove('target-indicator'); // S'assurer que ma grille n'a pas l'indicateur rouge
                        opponentGridElement.style.pointerEvents = 'none'; // D√©sactive les clics sur la grille adverse
                    }
                    break;

                case 'finished':
                    multiplayerLobby.classList.add('hidden');
                    gameContainer.classList.remove('hidden');
                    placementControls.classList.add('hidden');
                    placementControls.style.display = 'none';
                    opponentGridSection.classList.remove('hidden');
                    simulationButtonsContainer.classList.add('hidden');
                    replayButton.classList.remove('hidden');

                    createGrid(myGridElement, false, false);
                    createGrid(opponentGridElement, true, false);
                    renderPlacedShipsOnMyGrid(myPlayerGridState, myPlayerShips);
                    renderOpponentGridShots(opponentPlayerGridState);

                    if (gameData.winner === currentUserId) {
                        gameMessageElement.textContent = "Tu as gagn√© ! üéâ";
                    } else if (gameData.winner !== null) {
                        gameMessageElement.textContent = "Tu as perdu ! üò≠";
                    } else {
                        gameMessageElement.textContent = "La partie est termin√©e.";
                    }
                    break;
            }
        }

        /**
         * G√©n√®re une grille HTML avec des cellules.
         * @param {HTMLElement} gridElement - L'√©l√©ment HTML o√π ins√©rer la grille.
         * @param {boolean} isOpponentGrid - Indique si c'est la grille de l'adversaire (cliquable pour tirer).
         * @param {boolean} isPlacementGrid - Indique si c'est la grille de placement (cliquable pour placer des bateaux).
         */
        function createGrid(gridElement, isOpponentGrid, isPlacementGrid) {
            gridElement.innerHTML = ''; // Nettoie la grille existante

            // Ajout des en-t√™tes de colonnes (chiffres)
            const emptyCell = document.createElement('div');
            emptyCell.classList.add('grid-cell', 'header');
            gridElement.appendChild(emptyCell); // Cellule vide en haut √† gauche

            for (let i = 1; i <= gridSize; i++) {
                const headerCell = document.createElement('div');
                headerCell.classList.add('grid-cell', 'header');
                headerCell.textContent = i;
                gridElement.appendChild(headerCell);
            }

            // Ajout des en-t√™tes de lignes (lettres) et des cellules de jeu
            for (let i = 0; i < gridSize; i++) {
                const headerCell = document.createElement('div');
                headerCell.classList.add('grid-cell', 'header');
                headerCell.textContent = alphabet[i];
                gridElement.appendChild(headerCell); // En-t√™te de ligne

                for (let j = 0; j < gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.id = `${isOpponentGrid ? 'opp' : 'my'}-${alphabet[i]}${j + 1}`; // ID unique pour chaque cellule

                    if (isOpponentGrid && !isPlacementGrid && gameData.currentPlayerTurn === currentUserId && gameData.status === 'playing') {
                        cell.addEventListener('click', () => handleCellClick(cell, i, j));
                    } else if (!isOpponentGrid && isPlacementGrid && gameData.status === 'placement') {
                        cell.addEventListener('click', () => handlePlacementClick(cell, i, j));
                        cell.addEventListener('mouseenter', () => handlePlacementHover(cell, i, j, true));
                        cell.addEventListener('mouseleave', () => handlePlacementHover(cell, i, j, false));
                    }
                    gridElement.appendChild(cell);
                }
            }
        }

        /**
         * Affiche la liste des bateaux √† placer.
         * @param {Array<object>} currentShips - La liste des bateaux du joueur actuel.
         */
        function renderShipsList(currentShips) {
            shipsListElement.innerHTML = '';
            currentShips.forEach(ship => {
                const shipDiv = document.createElement('div');
                shipDiv.classList.add('ship-to-place', 'rounded-lg', 'shadow-md');
                shipDiv.textContent = `${ship.name} (${ship.length} cases)`;
                shipDiv.dataset.shipId = ship.id;

                if (ship.placed) {
                    shipDiv.style.backgroundColor = ship.color; // Applique la couleur du bateau
                    shipDiv.style.opacity = '0.9'; // Maintient l'opacit√©
                    shipDiv.style.cursor = 'default'; // Rendre non cliquable visuellement
                } else {
                    shipDiv.style.backgroundColor = 'var(--color-steel-gray)'; // Couleur par d√©faut pour non plac√©
                    shipDiv.style.cursor = 'pointer'; // Rendre cliquable
                }
                
                // Ajoute l'√©couteur d'√©v√©nement seulement si en phase de placement
                if (gameData.status === 'placement' && !ship.placed) { // Ne peut s√©lectionner que les bateaux non encore plac√©s
                    shipDiv.addEventListener('click', () => selectShipForPlacement(ship));
                }
                
                if (selectedShip !== null && selectedShip.id === ship.id) {
                    shipDiv.classList.add('selected');
                }
                shipsListElement.appendChild(shipDiv);
            });
            checkAllShipsPlaced(currentShips);
        }

        /**
         * S√©lectionne un bateau pour le placement.
         * @param {object} ship - L'objet bateau √† s√©lectionner.
         */
        function selectShipForPlacement(ship) {
            if (gameData.status !== 'placement') return;
            // Ne permet pas de s√©lectionner un bateau d√©j√† plac√©
            if (ship.placed) {
                gameMessageElement.textContent = `Le ${ship.name} est d√©j√† plac√© !`;
                return;
            }

            // Si le bateau est d√©j√† s√©lectionn√©, le d√©s√©lectionne
            if (selectedShip && selectedShip.id === ship.id) {
                const prevSelectedDiv = shipsListElement.querySelector(`[data-ship-id="${selectedShip.id}"]`);
                if (prevSelectedDiv) {
                    prevSelectedDiv.classList.remove('selected');
                }
                selectedShip = null;
                gameMessageElement.textContent = "Bateau d√©s√©lectionn√©. S√©lectionne un bateau √† placer.";
                removeShipPreview(); // Supprime l'aper√ßu
                return;
            }

            // D√©s√©lectionne le bateau pr√©c√©dent s'il y en avait un
            if (selectedShip) {
                const prevSelectedDiv = shipsListElement.querySelector(`[data-ship-id="${selectedShip.id}"]`);
                if (prevSelectedDiv) {
                    prevSelectedDiv.classList.remove('selected');
                }
            }

            selectedShip = ship;
            currentShipOrientation = 'horizontal'; // R√©initialise l'orientation √† chaque s√©lection

            // S√©lectionne le nouveau bateau
            const newSelectedDiv = shipsListElement.querySelector(`[data-ship-id="${ship.id}"]`);
            if (newSelectedDiv) {
                newSelectedDiv.classList.add('selected');
            }
            gameMessageElement.textContent = `Bateau s√©lectionn√© : ${ship.name}. Clique sur ta grille pour le placer.`;
            renderShipsList(currentPlayerNumber === 1 ? gameData.player1Ships : gameData.player2Ships);
        }

        /**
         * G√®re le clic sur une cellule de la grille du joueur pour placer un bateau.
         * @param {HTMLElement} cell - La cellule cliqu√©e.
         * @param {number} row - L'indice de la ligne.
         * @param {number} col - L'indice de la colonne.
         */
        async function handlePlacementClick(cell, row, col) {
            if (gameData.status !== 'placement') return;
            if (!selectedShip) {
                gameMessageElement.textContent = "S√©lectionne d'abord un bateau dans la liste !";
                return;
            }

            const currentPlayerShips = currentPlayerNumber === 1 ? gameData.player1Ships : gameData.player2Ships;
            const currentPlayerGrid = currentPlayerNumber === 1 ? gameData.player1Grid : gameData.player2Grid;

            // V√©rifie si le placement est valide
            const placementValid = checkPlacementValidity(row, col, selectedShip.length, currentShipOrientation, currentPlayerGrid);

            if (placementValid) {
                const newShipPosition = getShipCells(row, col, selectedShip.length, currentShipOrientation);
                const updatedShips = currentPlayerShips.map(s => 
                    s.id === selectedShip.id ? { ...s, placed: true, position: newShipPosition } : s
                );
                
                // Mettre √† jour la grille locale pour l'aper√ßu avant l'envoi √† Firestore
                let newGridState = JSON.parse(JSON.stringify(currentPlayerGrid));
                newShipPosition.forEach(p => {
                    newGridState[p.row][p.col] = 1; // Marque la cellule comme contenant un bateau
                });

                // Mettre √† jour Firestore
                const updates = {};
                if (currentPlayerNumber === 1) {
                    updates.player1Ships = updatedShips;
                    updates.player1Grid = newGridState;
                } else {
                    updates.player2Ships = updatedShips;
                    updates.player2Grid = newGridState;
                }
                await updateGameInFirestore(updates);

                selectedShip = null; // D√©s√©lectionne le bateau
                gameMessageElement.textContent = `"${selectedShip?.name || 'Bateau'}" plac√© !`; // Message mis √† jour par le listener
            } else {
                gameMessageElement.textContent = "Placement invalide : chevauchement ou hors grille !";
            }
            removeShipPreview();
        }

        /**
         * Affiche un aper√ßu du bateau lors du survol de la grille.
         * @param {HTMLElement} cell - La cellule survol√©e.
         * @param {number} row - L'indice de la ligne.
         * @param {number} col - L'indice de la colonne.
         * @param {boolean} isEntering - Vrai si le curseur entre, faux s'il sort.
         */
        function handlePlacementHover(cell, row, col, isEntering) {
            if (gameData.status !== 'placement') return;
            if (!selectedShip) return;

            removeShipPreview(); // Toujours supprimer l'ancien aper√ßu

            if (isEntering) {
                const currentPlayerGrid = currentPlayerNumber === 1 ? gameData.player1Grid : gameData.player2Grid;
                const previewCells = getShipCells(row, col, selectedShip.length, currentShipOrientation);
                const placementValid = checkPlacementValidity(row, col, selectedShip.length, currentShipOrientation, currentPlayerGrid);

                previewCells.forEach(pCell => {
                    const targetCell = document.getElementById(`my-${alphabet[pCell.row]}${pCell.col + 1}`);
                    if (targetCell) {
                        const previewDiv = document.createElement('div');
                        previewDiv.classList.add('ship-preview');
                        if (!placementValid) {
                            previewDiv.classList.add('invalid-placement');
                        }
                        targetCell.appendChild(previewDiv);
                    }
                });
            }
        }

        /**
         * Supprime tous les aper√ßus de bateau de la grille.
         */
        function removeShipPreview() {
            document.querySelectorAll('.ship-preview').forEach(preview => preview.remove());
        }

        /**
         * V√©rifie si le placement d'un bateau est valide.
         * @param {number} startRow - Ligne de d√©part.
         * @param {number} startCol - Colonne de d√©part.
         * @param {number} length - Longueur du bateau.
         * @param {string} orientation - Orientation ('horizontal' ou 'vertical').
         * @param {Array<Array<number>>} gridState - L'√©tat de la grille √† v√©rifier.
         * @returns {boolean} Vrai si le placement est valide.
         */
        function checkPlacementValidity(startRow, startCol, length, orientation, gridState) {
            const cellsToCheck = getShipCells(startRow, startCol, length, orientation);

            for (const cellPos of cellsToCheck) {
                // V√©rifie si hors grille
                if (cellPos.row < 0 || cellPos.row >= gridSize || cellPos.col < 0 || cellPos.col >= gridSize) {
                    return false;
                }
                // V√©rifie si la case est d√©j√† occup√©e par un bateau
                if (gridState[cellPos.row][cellPos.col] === 1) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Retourne les coordonn√©es des cellules qu'occuperait un bateau.
         * @param {number} startRow - Ligne de d√©part.
         * @param {number} startCol - Colonne de d√©part.
         * @param {number} length - Longueur du bateau.
         * @param {string} orientation - Orientation ('horizontal' ou 'vertical').
         * @returns {Array<object>} Tableau d'objets {row, col}.
         */
        function getShipCells(startRow, startCol, length, orientation) {
            const cells = [];
            for (let i = 0; i < length; i++) {
                let currentRow = startRow;
                let currentCol = startCol;
                if (orientation === 'horizontal') {
                    currentCol += i;
                } else {
                    currentRow += i;
                }
                cells.push({ row: currentRow, col: currentCol });
            }
            return cells;
        }

        /**
         * Fait pivoter l'orientation du bateau s√©lectionn√©.
         */
        rotateShipButton.addEventListener('click', () => {
            if (selectedShip && gameData.status === 'placement') {
                currentShipOrientation = (currentShipOrientation === 'horizontal') ? 'vertical' : 'horizontal';
                gameMessageElement.textContent = `Orientation : ${currentShipOrientation === 'horizontal' ? 'Horizontale' : 'Verticale'}`;
                // Mettre √† jour l'aper√ßu si le curseur est sur la grille
                const activeCell = document.querySelector('.grid-cell:hover');
                if (activeCell && activeCell.id.startsWith('my-')) {
                    const row = parseInt(activeCell.dataset.row);
                    const col = parseInt(activeCell.dataset.col);
                    handlePlacementHover(activeCell, row, col, true);
                }
            } else if (gameData.status !== 'placement') {
                gameMessageElement.textContent = "La rotation n'est possible qu'en phase de placement !";
            } else {
                gameMessageElement.textContent = "S√©lectionne un bateau √† faire pivoter !";
            }
        });

        /**
         * V√©rifie si tous les bateaux ont √©t√© plac√©s et active le bouton de validation.
         * @param {Array<object>} currentShips - La liste des bateaux du joueur actuel.
         */
        function checkAllShipsPlaced(currentShips) {
            const allPlaced = currentShips.every(ship => ship.placed);
            validatePlacementButton.disabled = !allPlaced;
            if (allPlaced) {
                gameMessageElement.textContent = "Tous les bateaux sont plac√©s ! Clique sur 'Valider mon placement'.";
            } else {
                gameMessageElement.textContent = "Place tes bateaux sur ta grille !"; // Message par d√©faut si tous ne sont pas plac√©s
            }
        }

        /**
         * G√®re le clic sur le bouton de validation du placement.
         */
        validatePlacementButton.addEventListener('click', async () => {
            const currentPlayerShips = currentPlayerNumber === 1 ? gameData.player1Ships : gameData.player2Ships;
            if (currentPlayerShips.every(ship => ship.placed)) {
                // Marquer le joueur comme ayant termin√© son placement
                const updates = {};
                if (currentPlayerNumber === 1) {
                    updates.player1PlacementDone = true;
                } else {
                    updates.player2PlacementDone = true;
                }
                await updateGameInFirestore(updates);

                // V√©rifier si les deux joueurs ont termin√© leur placement
                const docSnap = await getDoc(doc(db, `artifacts/${appId}/public/data/battleship_games`, currentGameId));
                const updatedGameData = docSnap.data();
                // D√©s√©rialiser les donn√©es pour la v√©rification
                const player1ShipsParsed = JSON.parse(updatedGameData.player1Ships);
                const player2ShipsParsed = JSON.parse(updatedGameData.player2Ships);


                if (updatedGameData.player1PlacementDone && updatedGameData.player2PlacementDone) {
                    // Si les deux joueurs ont fini, passer √† la phase de jeu
                    await updateGameInFirestore({ status: 'playing', currentPlayerTurn: updatedGameData.player1Id }); // Player 1 commence
                } else {
                    gameMessageElement.textContent = "Placement valid√© ! En attente de l'autre joueur...";
                }
            } else {
                gameMessageElement.textContent = "Tu dois placer tous tes bateaux avant de valider !";
            }
        });


        /**
         * Re-rend les bateaux plac√©s sur ma grille apr√®s un changement de phase.
         * @param {Array<Array<number>>} myGridState - L'√©tat de la grille du joueur.
         * @param {Array<object>} myShips - Les bateaux du joueur.
         */
        function renderPlacedShipsOnMyGrid(myGridState, myShips) {
            // Nettoie tous les √©l√©ments de bateau existants sur la grille
            myGridElement.querySelectorAll('.ship').forEach(shipDiv => shipDiv.remove());

            myShips.forEach(ship => {
                if (ship.placed && ship.position && ship.position.length > 0) {
                    ship.position.forEach(cellPos => {
                        const cellElement = document.getElementById(`my-${alphabet[cellPos.row]}${cellPos.col + 1}`);
                        if (cellElement) {
                            const shipDiv = document.createElement('div');
                            shipDiv.classList.add('ship');
                            shipDiv.dataset.shipId = ship.id;
                            if (ship.color) {
                                shipDiv.style.backgroundColor = ship.color;
                            }
                            cellElement.appendChild(shipDiv);
                        }
                    });
                }
            });

            // Affiche les tirs sur ma grille (ceux de l'adversaire)
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.getElementById(`my-${alphabet[i]}${j + 1}`);
                    const existingMarker = cell.querySelector('.emoji-marker');
                    if (existingMarker) {
                        existingMarker.remove();
                    }
                    // 2 = touch√© par l'adversaire, 3 = manqu√© par l'adversaire
                    if (myGridState[i][j] === 2) { 
                        const marker = document.createElement('span');
                        marker.classList.add('emoji-marker');
                        marker.textContent = 'üî•';
                        cell.appendChild(marker);
                    } else if (myGridState[i][j] === 3) { 
                        const marker = document.createElement('span');
                        marker.classList.add('emoji-marker');
                        marker.textContent = 'üí¶';
                        cell.appendChild(marker);
                    }
                }
            }
        }

        /**
         * Affiche les tirs (touch√©s/manqu√©s) sur la grille de l'adversaire (celle que le joueur a tir√©e).
         * @param {Array<Array<number>>} opponentGridState - L'√©tat de la grille de l'adversaire.
         */
        function renderOpponentGridShots(opponentGridState) {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.getElementById(`opp-${alphabet[i]}${j + 1}`);
                    // Supprime les marqueurs existants avant de les recr√©er
                    const existingMarker = cell.querySelector('.emoji-marker');
                    if (existingMarker) {
                        existingMarker.remove();
                    }

                    if (opponentGridState[i][j] === 2) { // 2 = touch√© par le joueur sur la grille de l'adversaire
                        const marker = document.createElement('span');
                        marker.classList.add('emoji-marker');
                        marker.textContent = 'üî•';
                        cell.appendChild(marker);
                    } else if (opponentGridState[i][j] === 3) { // 3 = manqu√© par le joueur sur la grille de l'adversaire
                        const marker = document.createElement('span');
                        marker.classList.add('emoji-marker');
                        marker.textContent = 'üí¶';
                        cell.appendChild(marker);
                    }
                }
            }
        }


        /**
         * G√®re le clic sur une cellule de la grille de l'adversaire (phase de jeu).
         * @param {HTMLElement} cell - L'√©l√©ment de la cellule cliqu√©e.
         * @param {number} row - L'indice de la ligne.
         * @param {number} col - L'indice de la colonne.
         */
        async function handleCellClick(cell, row, col) {
            if (gameData.status !== 'playing' || gameData.currentPlayerTurn !== currentUserId) {
                gameMessageElement.textContent = "Ce n'est pas ton tour !";
                return;
            }

            // D√©termine quelle grille de l'adversaire est cibl√©e et l'√©tat de ses bateaux
            let targetPlayerGridKey = (currentPlayerNumber === 1) ? 'player2Grid' : 'player1Grid';
            let targetPlayerShipsKey = (currentPlayerNumber === 1) ? 'player2Ships' : 'player1Ships';
            
            let targetPlayerGrid = gameData[targetPlayerGridKey];
            let targetPlayerShips = gameData[targetPlayerShipsKey];

            // Emp√™che de tirer sur une case d√©j√† tir√©e
            if (targetPlayerGrid[row][col] === 2 || targetPlayerGrid[row][col] === 3) {
                gameMessageElement.textContent = "Vous avez d√©j√† tir√© ici !";
                return;
            }

            // V√©rifie si le tir touche un bateau de l'adversaire
            const hitShipIndex = targetPlayerShips.findIndex(ship => 
                ship.position.some(p => p.row === row && p.col === col)
            );

            const updates = {};
            let newGridState = JSON.parse(JSON.stringify(targetPlayerGrid));
            let newShipsState = JSON.parse(JSON.stringify(targetPlayerShips));

            if (hitShipIndex !== -1) {
                // Touch√©
                newGridState[row][col] = 2; // Marque comme touch√©
                newShipsState[hitShipIndex].hits++;
                
                // V√©rifie si le bateau est coul√©
                if (newShipsState[hitShipIndex].hits === newShipsState[hitShipIndex].length) {
                    newShipsState[hitShipIndex].sunk = true;
                    gameMessageElement.textContent = `Touch√© ! Tu as coul√© le ${newShipsState[hitShipIndex].name} de l'adversaire !`;
                } else {
                    gameMessageElement.textContent = `Touch√© ! Tu as touch√© un ${newShipsState[hitShipIndex].name} !`;
                }
            } else {
                // Manqu√©
                newGridState[row][col] = 3; // Marque comme manqu√©
                gameMessageElement.textContent = "Dans l'eau ! üíß";
            }

            updates[targetPlayerGridKey] = newGridState;
            updates[targetPlayerShipsKey] = newShipsState;
            
            // V√©rifie la fin de partie
            const opponentShipsSunk = newShipsState.every(ship => ship.sunk);
            if (opponentShipsSunk) {
                updates.status = 'finished';
                updates.winner = currentUserId;
                gameMessageElement.textContent = "Tous les bateaux de l'adversaire sont coul√©s ! Tu as gagn√© ! üéâ";
            } else {
                // Passe le tour √† l'autre joueur
                updates.currentPlayerTurn = (gameData.player1Id === currentUserId) ? gameData.player2Id : gameData.player1Id;
            }
            
            await updateGameInFirestore(updates);
        }

        // √âv√©nements pour les boutons de simulation (maintenant inutiles en multijoueur)
        simulateHitButton.addEventListener('click', () => {
            gameMessageElement.textContent = "Les boutons de simulation sont d√©sactiv√©s en mode multijoueur.";
        });

        simulateMissButton.addEventListener('click', () => {
            gameMessageElement.textContent = "Les boutons de simulation sont d√©sactiv√©s en mode multijoueur.";
        });

        // √âv√©nement pour le bouton Rejouer
        replayButton.addEventListener('click', resetGame);

        // Initialisation au chargement de la page
        window.onload = function() {
            // Le lobby multijoueur est affich√© par d√©faut
            multiplayerLobby.classList.remove('hidden');
            gameContainer.classList.add('hidden'); // Le jeu principal est cach√©
            placementControls.classList.add('hidden'); // Les contr√¥les de placement sont cach√©s
        };
    </script>
</body>
</html>
